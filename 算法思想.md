# 算法思想

## 枚举

枚举算法（Enumeration Algorithm）是一种基本的搜索算法，用于在给定范围内系统地列举所有可能的解。这种算法通常用于解决组合优化问题，如子集和、排列组合等。其基本思想是通过遍历所有可能的解空间来找到问题的解。

枚举算法的一般步骤如下：

1. 确定问题的解空间：首先确定问题的解空间，即可能的解的范围。

2. 生成可能的解：按照某种规则逐个生成解空间中的所有可能解，通常是通过遍历组合或排列来实现。

3. 判断解的有效性：对于生成的每个解，需要验证其是否符合问题的约束条件，只有符合条件的解才是有效解。

4. 记录有效解：将有效解记录下来，或者根据问题要求进行处理（如找到最优解或满足特定条件的解）。

5. 终止条件：继续生成解直到完成全部可能的组合，或者当满足某个终止条件时停止。

枚举算法的优点是简单易懂，并且能够保证找到问题的解（如果存在）。然而，由于其需要穷尽所有可能的解，因此在解空间较大时，枚举算法的时间复杂度会很高，效率不高。因此，在实际应用中，通常会针对具体问题选择更加高效的算法。

案例：“百钱买百鸡”，今有鸡翁一，值钱五，鸡母一，值钱三，鸡雏三，值钱一，凡百钱买鸡百只，问鸡翁、母、雏各几何？

```java
class Solution {
    public void buyChickens() {
        for (int x = 0; x <= 20; x++) {
            for (int y = 0; y <= 33; y++) {
                int z = 100 - x - y;
                if (z % 3 == 0 && (x * 5 + y * 3 + z / 3) == 100) {
                    System.out.printf("%d %d %d%n", x, y, z);
                }
            }
        }
    }
}
```

## 递归

递归算法（Recursive Algorithm）是一种通过函数自身调用来解决问题的算法。它通常包含以下几个关键要素：

1. 基本情况（Base Case）：定义问题的最简单情况，通常是无法再进行递归调用的情况。

2. 递归调用（Recursive Call）：在函数内部调用自身，但是规模较前一次调用要更小，以解决更简单的问题。

3. 递归停止条件（Termination Condition）：确保递归的过程最终会停止，避免陷入无限循环。

递归算法通常用于解决具有递归结构的问题，比如树、图等。常见的例子包括：

1. 阶乘计算：n! = n × (n−1)!，其中 n! 是 n 的阶乘。

2. 斐波那契数列：F(n) = F(n-1) + F(n-2)，其中 F(n) 是斐波那契数列的第 n 项。

3. 树的遍历：前序遍历、中序遍历、后序遍历等。

4. 图的深度优先搜索（DFS）和广度优先搜索（BFS）。

递归算法的优点是简洁、易于理解，能够直接表达问题的递归结构，但同时也存在一些缺点，如性能不稳定、可能导致栈溢出等问题。在实际应用中，需要根据具体情况选择是否采用递归算法，并注意优化递归调用，避免不必要的重复计算。

## 分治

分治算法（Divide and Conquer）是一种解决问题的算法范式，它将一个大问题分解成若干个规模较小的子问题，然后分别解决这些子问题，最后将子问题的解合并起来得到原问题的解。分治算法通常包含以下三个步骤：

1. 分解（Divide）：将原问题分解成若干个规模较小的子问题。

2. 解决（Conquer）：递归地解决子问题。如果子问题足够小，则直接求解；否则继续分解。

3. 合并（Combine）：将子问题的解合并成原问题的解。

分治算法通常适用于满足以下条件的问题：

1. 问题具有递归结构：问题可以分解成若干个相同类型的子问题。

2. 子问题相互独立：子问题之间不会相互影响，每个子问题的解可以独立求解。

3. 合并子问题的解容易：子问题的解可以有效地合并成原问题的解。

常见的分治算法应用包括：

- 归并排序（Merge Sort）：将数组分成两部分，分别排序后再合并。

- 快速排序（Quick Sort）：选择一个基准元素，将数组分成两部分，小于基准的放左边，大于基准的放右边，然后递归地对左右两部分排序。

- 二分查找（Binary Search）：将有序数组分成两部分，每次查找排除一半的元素。

- 最接近点对问题：在一个点集中找到距离最近的一对点。

分治算法通常具有高效性和可并行性的特点，但也存在一些问题，如递归深度过深可能导致栈溢出，以及合并子问题的解可能需要额外的开销。在实际应用中，需要根据问题的性质和规模选择合适的算法。

## 动态规划

动态规划（Dynamic Programming）是一种解决多阶段决策问题的数学方法和计算机算法思想。它通常用于解决具有重叠子问题和最优子结构性质的问题。动态规划的基本思想是将问题分解成若干个子问题，然后通过递推关系式求解子问题，并将子问题的解保存起来，避免重复计算，从而达到降低时间复杂度的目的。

动态规划通常包含以下几个步骤：

确定状态：定义问题的状态，使得原问题和子问题都能够用这些状态来描述。

建立状态转移方程：找出问题的状态之间的递推关系，即如何从一个状态转移到另一个状态。

初始化：确定初始状态的值。

递推求解：按照状态转移方程，从初始状态逐步计算出问题的解。

输出结果：根据最终的状态值得到问题的解。

动态规划通常适用于具有最优子结构性质的问题，即原问题的最优解包含了其子问题的最优解。常见的动态规划问题包括：

- 背包问题（Knapsack Problem）

- 最长递增子序列（Longest Increasing Subsequence）

- 最大子数组和（Maximum Subarray Sum）

- 最短路径问题（Shortest Path Problem）

- 矩阵链乘法（Matrix Chain Multiplication）

- 编辑距离（Edit Distance）

- 动态规划在解决各种优化、排列、组合问题中的应用

动态规划算法的时间复杂度通常是问题规模的多项式函数，但需要注意的是，动态规划算法在空间上通常需要额外的存储空间来保存子问题的解，因此可能会消耗较多的内存。

## 贪心

贪心算法（Greedy Algorithm）是一种在每一步选择中都采取当前状态下最优决策的算法。它通过在每一步选择中都做出局部最优的选择，希望最终能够达到全局最优解。贪心算法通常适用于满足以下两个条件的问题：

1. 最优子结构（Optimal Substructure）：问题的最优解包含了其子问题的最优解。换句话说，问题的最优解可以通过子问题的最优解来构造。

2. 贪心选择性质（Greedy Choice Property）：通过选择当前状态下的最优解，可以期望最终得到全局最优解。

贪心算法通常不保证得到最优解，但对于一些问题，贪心算法能够得到全局最优解。然而，对于另一些问题，贪心算法可能会得到局部最优解而不是全局最优解。因此，在应用贪心算法时，需要仔细分析问题的性质，以确定是否适合使用贪心算法。

常见的贪心算法应用包括：

- 最小生成树（Minimum Spanning Tree）

- 最短路径问题（Shortest Path Problem）

- 背包问题（Knapsack Problem）

- 活动安排问题（Activity Selection Problem）

- 调度问题（Scheduling Problem）

贪心算法通常具有简单、高效的特点，适用于一些问题的解决，但也需要注意，它并不适用于所有类型的问题，有时需要其他更复杂的算法来获得最优解。

## 回溯
