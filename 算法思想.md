# 算法思想

## 枚举

枚举算法（Enumeration Algorithm）是一种基本的搜索算法，用于在给定范围内系统地列举所有可能的解。这种算法通常用于解决组合优化问题，如子集和、排列组合等。其基本思想是通过遍历所有可能的解空间来找到问题的解。

枚举算法的一般步骤如下：

1. 确定问题的解空间：首先确定问题的解空间，即可能的解的范围。

2. 生成可能的解：按照某种规则逐个生成解空间中的所有可能解，通常是通过遍历组合或排列来实现。

3. 判断解的有效性：对于生成的每个解，需要验证其是否符合问题的约束条件，只有符合条件的解才是有效解。

4. 记录有效解：将有效解记录下来，或者根据问题要求进行处理（如找到最优解或满足特定条件的解）。

5. 终止条件：继续生成解直到完成全部可能的组合，或者当满足某个终止条件时停止。

枚举算法的优点是简单易懂，并且能够保证找到问题的解（如果存在）。然而，由于其需要穷尽所有可能的解，因此在解空间较大时，枚举算法的时间复杂度会很高，效率不高。因此，在实际应用中，通常会针对具体问题选择更加高效的算法。

案例：“百钱买百鸡”，今有鸡翁一，值钱五，鸡母一，值钱三，鸡雏三，值钱一，凡百钱买鸡百只，问鸡翁、母、雏各几何？

```java
class Solution {
    public void buyChickens() {
        for (int x = 0; x <= 20; x++) {
            for (int y = 0; y <= 33; y++) {
                int z = 100 - x - y;
                if (z % 3 == 0 && (x * 5 + y * 3 + z / 3) == 100) {
                    System.out.printf("%d %d %d%n", x, y, z);
                }
            }
        }
    }
}
```

## 递归

递归算法（Recursive Algorithm）是一种通过函数自身调用来解决问题的算法。它通常包含以下几个关键要素：

1. 基本情况（Base Case）：定义问题的最简单情况，通常是无法再进行递归调用的情况。

2. 递归调用（Recursive Call）：在函数内部调用自身，但是规模较前一次调用要更小，以解决更简单的问题。

3. 递归停止条件（Termination Condition）：确保递归的过程最终会停止，避免陷入无限循环。

递归算法通常用于解决具有递归结构的问题，比如树、图等。常见的例子包括：

1. 阶乘计算：n! = n × (n−1)!，其中 n! 是 n 的阶乘。

2. 斐波那契数列：F(n) = F(n-1) + F(n-2)，其中 F(n) 是斐波那契数列的第 n 项。

3. 树的遍历：前序遍历、中序遍历、后序遍历等。

4. 图的深度优先搜索（DFS）和广度优先搜索（BFS）。

递归算法的优点是简洁、易于理解，能够直接表达问题的递归结构，但同时也存在一些缺点，如性能不稳定、可能导致栈溢出等问题。在实际应用中，需要根据具体情况选择是否采用递归算法，并注意优化递归调用，避免不必要的重复计算。

## 分治

## 动态规划

## 贪心

## 回溯
